<form action="/action_page.php" method="post">
    <p>RA: {{ target.ra }}</p>
    <p>Dec: {{ target.dec }}</p>
    {% csrf_token %}
    {{ form }}
    <input type="submit" value="Submit">
</form>

##############################33

def get(self, request, pk):
    if request.method == 'POST':
        form = QueryForm(request.POST)
        if form.is_valid():
            # this should be the outputted data table generated by ATLAS
            # must insert an asynchronous support as the data is loaded through ATLAS so server doesn't timeout
            return HttpResponseRedirect(main_func(self, request, *args, **kwargs), thread_sensitive=True)
    else:
        form = QueryForm()

    return render(request, 'query.html', {'form': form})


# Main function that will take inputted data from forms into 'atlas_query.py' script frame
# and display data


def main_func(self, request, *args, **kwargs):
    print(f'request: {request}')
    print(f'request: {dir(request)}')

    RA = self.object.ra
    Dec = self.object.dec

    MJD = request.POST["MJD"]  # data from atlas_form.html

    BASEURL = settings.BROKERS['ATLAS']['BASEURL']

    if os.environget("ATLASFORCED_SECRET_KEY"):
        token = os.environ.get("ATLASFORCED_SECRET_KEY")
        print("Using stored token")

    else:
        data = {"username": settings.BROKERS['ATLAS']['USER'],
                "password": settings.BROKERS['ATLAS']['PASS']}  # set up user authentication

        resp = requests.post(url=f"{BASEURL}/api-token-auth/", data=data)

        if resp.status_code == 200:
            token = resp.json()["token"]
            print(f"Your token is {token}")
            print("Store this by running/adding to your .zshrc file:")
            print(f'export ATLASFORCED_SECRET_KEY="{token}"')
        else:
            print(f"ERROR {resp.status_code}")
            print(resp.text)
            sys.exit()

    headers = {"Authorization": f"Token {token}", "Accept": "application/json"}

    task_url = None
    while not task_url:
        with requests.Session() as s:
            resp = s.post(
                f"{BASEURL}/queue/", headers=headers, data={"ra": RA, "dec": Dec, "mjd_min": MJD, "send_email": False})

            if resp.status_code == 201:
                task_url = resp.json()["url"]
                print(f"The task url is {task_url}")
            elif resp.status_code == 429:
                message = resp.json()["detail"]
                print(f"{resp.status_code} {message}")
                t_sec = re.findall(r"available in (\d+) seconds", message)
                t_min = re.findall(r"available in (\d+) minutes", message)
                if t_sec:
                    waittime = int(t_sec[0])
                elif t_min:
                    waittime = int(t_min[0]) * 60
                else:
                    waittime = 10
                print(f"Waiting {waittime} seconds")
                time.sleep(waittime)
            else:
                print(f"ERROR {resp.status_code}")
                print(resp.text)
                sys.exit()
    result_url = None
    taskstarted_printed = False
    while not result_url:
        with requests.Session() as s:
            resp = s.get(task_url, headers=headers)

            if resp.status_code == 200:
                if resp.json()["finishtimestamp"]:
                    result_url = resp.json()["result_url"]  # PART WHEN QUERY IS COMPLETE
                    print(f"Task is complete with results available at {result_url}")
                elif resp.json()["starttimestamp"]:
                    if not taskstarted_printed:
                        print(f"Task is running (started at {resp.json()['starttimestamp']})")
                        taskstarted_printed = True
                    time.sleep(2)
                else:
                    print(f"Waiting for job to start (queued at {resp.json()['timestamp']})")
                    time.sleep(4)
            else:
                print(f"ERROR {resp.status_code}")
                print(resp.text)
                sys.exit()
    with requests.Session() as s:
        textdata = s.get(result_url, headers=headers).text

    reduced_data = run_data_processor(textdata)

    return reduced_data


####################################################

def post(self, request, pk):
    if request.method == 'POST':
        form = QueryForm(request.POST)

        if form.is_valid():
            return HttpResponseRedirect("/thanks/")
    else:
        form = QueryForm()

######################################################

<form action="" method="post">
 <label for="MJD">MJD min:</label><br>
 <input type="text" id="MJD" name="MJD"><br><br>
</form>

################################

<form action="/your-name/" method="GET">
 <label for="MJD">MJD min:</label><br>
 <input type="text" id="MJD" name="MJD"><br><br>
</form>

#######################################################3

class QueryView_original(DetailView):   #MainFunctionView
	template_name = 'query.html'
	model = Target

	def get_context_data(self, **kwargs):
		print(f'get_context_data -- kwargs: {kwargs}')
		return {'target': self.get_object()}

	def get(self, request, pk):
		super().get(request, pk)
		print(f'get -- request: {request}')
		form = QueryForm(request.POST)
		print(f'get -- form: {form}')
		context = self.get_context_data()
		context.update({'form': form})
		print(f'get -- context: {context}')
		return render(request, 'query.html', context)   # inserting form here is the issue

	def post(self, request, pk):
		print(f'post -- request: {request}')
		if request.method == 'POST':
			form = QueryForm(request.POST)

			if form.is_valid():

				return HttpResponseRedirect("/thanks/")
			else:
				form = QueryForm()
		print(f'post -- form: {form}')
		return render(request, 'query.html', {'form':form})   # inserting form here is the issue





########################################################


	dt.append(io.TextIOWrapper(textdata))

	print(f'this is it: {dt}')

	#testing = []

	#for lines in textdata:
	#	testing.append(lines)

	#def function(a):
	#	return ''.join(char or ' ' for char in a)

	#data = []

	#data.append(function(testing))

	#print(f"this is the data: {data}")